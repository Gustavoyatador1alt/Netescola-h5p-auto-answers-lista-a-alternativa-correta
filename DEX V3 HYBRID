// ==UserScript==
// @name         DEX V3 (suporte base64 imagens)
// @namespace    http://tampermonkey.net/
// @version      3.6
// @description  Marca respostas corretas (MultiChoice e SingleChoice) incluindo alternativas que usam imagens em data:image/base64 e avanÃ§a automaticamente no H5P.
// @author       Gustavoyatador
// @match        https://sergoias.portal.sagreseduca.com.br/*
// @match        https://sergoias.portal.sagreseduca.com.br/*
// @grant        none
// @run-at       document-end
// @allFrames    true
// ==/UserScript==

(function () {
  'use strict';

  // ğŸš€ Injetar Eruda (console visual)
  (function addEruda() {
    if (window.eruda) return;
    const script = document.createElement('script');
    script.src = "https://cdn.jsdelivr.net/npm/eruda";
    script.onload = () => { try { eruda.init(); } catch {} };
    document.body.appendChild(script);
  })();
// ğŸ”§ Melhor limpeza e normalizaÃ§Ã£o de texto
const clean = (html) => {
  if (!html) return "";
  // MantÃ©m o conteÃºdo de sup/sub com marcaÃ§Ã£o visual simples
  let text = html
    .replace(/<sup>(.*?)<\/sup>/gi, "^($1)")   // transforma Â²Â³â¸U â†’ ^(238)U
    .replace(/<sub>(.*?)<\/sub>/gi, "_($1)")   // subscrito (quÃ­mica)
    .replace(/<img[^>]+alt="([^"]*)"[^>]*>/gi, " $1 ") // imagem com alt
    .replace(/<img[^>]+>/gi, "[img]")          // imagem sem alt
    .replace(/&nbsp;/g, " ")
    .replace(/<[^>]*>/g, " ")                  // remove tags restantes
    .replace(/\s+/g, " ")
    .trim();
  return text;
};

const tryParse = (s) => {
  try { return typeof s === "string" ? JSON.parse(s) : s; }
  catch { return null; }
};

const pullParams = (obj = {}) =>
  obj.params && (obj.params.answers || obj.params.question) ? obj.params : obj;

// ğŸ”¡ Normaliza texto pra comparaÃ§Ã£o robusta
const normalize = (s) =>
  String(s || "")
    .toLowerCase()
    .replace(/[^\p{L}\p{N}^_()]+/gu, " ") // mantÃ©m letras, nÃºmeros, ^ e _
    .replace(/\s+/g, " ")
    .trim();

  // nova: fingerprint curta de base64 (para comparar imagens data:)
  function shortBase64(b64) {
    if (!b64 || typeof b64 !== 'string') return '';
    const comma = b64.indexOf(',');
    const payload = comma >= 0 ? b64.slice(comma + 1) : b64;
    // pega pedaÃ§os iniciais e finais para reduzir colisÃµes
    return payload.slice(0, 60) + (payload.length > 120 ? payload.slice(-20) : '');
  }

  // ğŸ§± Caixa de status flutuante
  function createBox(doc = document) {
    let box = doc.getElementById('dex-box');
    if (!box) {
      box = doc.createElement('div');
      box.id = 'dex-box';
      Object.assign(box.style, {
        position: 'fixed',
        top: '60px',
        left: '20px',
        minWidth: '260px',
        maxWidth: '420px',
        background: '#1a1f2b',
        color: '#fff',
        border: '2px solid #2c3e50',
        borderRadius: '10px',
        padding: '8px 12px',
        fontSize: '13px',
        lineHeight: '1.4',
        zIndex: '999999',
        boxShadow: '0 0 15px rgba(0,0,0,0.4)',
        cursor: 'move',
        userSelect: 'none'
      });

      let isDown = false, offsetX = 0, offsetY = 0;
      box.addEventListener('mousedown', (e) => {
        isDown = true;
        offsetX = e.clientX - box.offsetLeft;
        offsetY = e.clientY - box.offsetTop;
      });
      doc.addEventListener('mouseup', () => (isDown = false));
      doc.addEventListener('mousemove', (e) => {
        if (isDown) {
          box.style.left = `${e.clientX - offsetX}px`;
          box.style.top = `${e.clientY - offsetY}px`;
        }
      });

      doc.body.appendChild(box);
    }
    return box;
  }

  // ğŸ§© ExtraÃ§Ã£o de respostas (agora com suporte a imagens base64)
  function extractRows(doc = document) {
    const rows = [];

    const extractImgFromHtml = (html) => {
      try {
        if (!html || typeof html !== 'string') return '';
        // procura data:image/...;base64,AAA...
        const m = html.match(/data:image\/[a-zA-Z0-9.+-]+;base64,[A-Za-z0-9+/=]+/);
        if (m) return m[0];
        // tambÃ©m tenta extrair src de <img src="...">
        const imgMatch = html.match(/<img[^>]+src=["']([^"']+)["']/i);
        if (imgMatch) return imgMatch[1];
        return '';
      } catch (e) { return ''; }
    };

    const pushFromParams = (raw) => {
      const p = pullParams(raw || {});
      const question = clean(p.question || p.prompt || p.stem || p.title || "");
      const answers = Array.isArray(p.answers) ? p.answers : [];
      answers.forEach((a, idx) => {
        const correct = a.correct === true || a.isCorrect === true || a.correctAnswer === true;
        // extrai texto e imagem (se existir)
        const rawHtml = a.text || a.label || a.content || "";
        const text = clean(rawHtml);
        const img = extractImgFromHtml(rawHtml);
        rows.push({
          question,
          idx,
          letter: String.fromCharCode(65 + idx),
          text,
          img, // url ou data:image...
          imgHash: img ? shortBase64(img) : '',
          correct,
          type: "H5P.MultiChoice"
        });
      });
    };

    const HI = doc.defaultView?.H5PIntegration;
    if (HI?.contents) {
      Object.values(HI.contents).forEach((val) => {
        const lib = String(val.library || "").split(" ")[0];
        if (lib === "H5P.MultiChoice") {
          const params = tryParse(val.jsonContent) || val.content || tryParse(val.params) || null;
          pushFromParams(params);
        }
      });
    }

    const H5P = doc.defaultView?.H5P;
    if (H5P && Array.isArray(H5P.instances)) {
      H5P.instances.forEach((inst) => {
        try {
          const lib = inst.libraryInfo?.machineName || inst.library?.machineName || inst?.constructor?.name;
          if (["H5P.MultiChoice", "H5P.SingleChoice"].includes(lib)) {
            const params = inst.options || inst.params || inst.contentData?.params || {};
            pushFromParams(params);
          }
        } catch (e) { /* ignore instance parse errors */ }
      });
    }

    // AdiÃ§Ã£o de suporte a <li class="h5p-sc-alternative ..."> (DOM)
    doc.querySelectorAll("li.h5p-sc-alternative").forEach((li, i) => {
      const correct = li.classList.contains("h5p-sc-is-correct");
      const rawHtml = li.innerHTML || li.textContent || '';
      // pega imagem se existir
      const imgNode = li.querySelector('img');
      const img = imgNode ? (imgNode.src || '') : (rawHtml.includes('data:image') ? (rawHtml.match(/data:image\/[a-zA-Z0-9.+-]+;base64,[A-Za-z0-9+/=]+/)?.[0]||'') : '');
      rows.push({
        question: "SingleChoice (DOM)",
        idx: i,
        letter: String.fromCharCode(65 + i),
        text: clean(li.innerText || ""),
        img,
        imgHash: img ? shortBase64(img) : '',
        correct,
        el: li, // guarda referÃªncia ao elemento DOM para clique direto
        type: "H5P.SingleChoice"
      });
    });

    return rows;
  }

// ... (cÃ³digo anterior)

Â  // ğŸ§  Marca respostas corretas automaticamente (agora com matching por Ã­ndice, imagem e texto)
Â  function autoAnswer(rows, doc = document) {
Â  Â  // Se tiver dados vindos do extractRows()
Â  Â  if (rows && rows.length > 0) {
Â  Â  Â  rows
Â  Â  Â  Â  .filter(r => r.correct)
Â  Â  Â  Â  .forEach(r => {
Â  Â  Â  Â  Â  let matched = false;
Â  Â  Â  Â  Â  const alternatives = Array.from(doc.querySelectorAll('.h5p-sc-alternative, .h5p-answer, li[role="radio"], .h5p-single-choice-wrapper ul > li'));

Â  Â  Â  Â  Â  // 1) âš¡ PRIORIDADE: Match por ÃNDICE (O mais rÃ¡pido e robusto)
Â  Â  Â  Â  Â  if (r.idx !== undefined && alternatives.length > r.idx) {
Â  Â  Â  Â  Â  Â  const el = alternatives[r.idx];
Â  Â  Â  Â  Â  Â  if (el && el instanceof Element) {
Â  Â  Â  Â  Â  Â  Â  el.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));
Â  Â  Â  Â  Â  Â  Â  matched = true;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // 2) ğŸ–¼ï¸ FALLBACK: Match por IMAGEM/Base64 (Se falhou por Ã­ndice)
Â  Â  Â  Â  Â  if (!matched && r.imgHash) {
Â  Â  Â  Â  Â  Â  const imgs = Array.from(doc.querySelectorAll('.h5p-sc-alternative, .h5p-answer, li, img'));
Â  Â  Â  Â  Â  Â  for (const candidate of imgs) {
Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  // Se for <img> direto
Â  Â  Â  Â  Â  Â  Â  Â  if (candidate.tagName && candidate.tagName.toLowerCase() === 'img') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  const src = candidate.src || '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  if (src && shortBase64(src) === r.imgHash) { candidate.click(); matched = true; break; }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  // procurar img dentro do candidate
Â  Â  Â  Â  Â  Â  Â  Â  Â  const imgNode = candidate.querySelector && candidate.querySelector('img');
Â  Â  Â  Â  Â  Â  Â  Â  Â  const src = imgNode ? imgNode.src : (candidate.innerHTML || '').match(/data:image\/[a-zA-Z0-9.+-]+;base64,[A-Za-z0-9+/=]+/)?.[0] || '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  if (src && shortBase64(src) === r.imgHash) { candidate.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true })); matched = true; break; }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  } catch (e) {}
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // 3) ğŸ“„ ÃšLTIMO FALLBACK: Match por TEXTO (Menos confiÃ¡vel)
Â  Â  Â  Â  Â  if (!matched && r.text) {
Â  Â  Â  Â  Â  Â  const el = alternatives
Â  Â  Â  Â  Â  Â  Â  .find(e => {
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  const t = e.innerText || '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  // A busca deve ser feita pelo texto limpo da resposta no JSON/API
Â  Â  Â  Â  Â  Â  Â  Â  Â  return t && normalize(t).includes(normalize(r.text));
Â  Â  Â  Â  Â  Â  Â  Â  } catch (e) { return false; }
Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  if (el) {
Â  Â  Â  Â  Â  Â  Â  el.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));
Â  Â  Â  Â  Â  Â  Â  matched = true;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // Log de resultado
Â  Â  Â  Â  Â  if (!matched) {
Â  Â  Â  Â  Â  Â  console.warn(`âš ï¸ NÃ£o achou alternativa: [${r.idx}] ${r.text || r.imgHash}`);
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  console.log(`âœ… Marcou correta (Match: ${r.idx !== undefined ? 'Ãndice' : r.imgHash ? 'Imagem' : 'Texto'}): ${r.text || r.imgHash}`);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  }

    // Caso ainda exista .h5p-sc-is-correct no DOM, garante o clique
    const correctEls = doc.querySelectorAll('.h5p-sc-alternative.h5p-sc-is-correct, .h5p-answer.correct');
    if (correctEls.length > 0) {
      correctEls.forEach(el =>
        el.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }))
      );
    }

    // SÃ³ clica no botÃ£o se ele existir
    const checkBtn = doc.querySelector(".h5p-question-check-answer, .h5p-multi-choice-submit, .h5p-sc-next, button[data-check], button[type='submit']");
    if (checkBtn && !checkBtn.disabled) {
      try { checkBtn.click(); } catch (e) {}
    }
  }

  // â–¶ï¸ Clicar no botÃ£o AvanÃ§ar
  function autoClickNext(doc = document) {
    // responded() pode nÃ£o existir no teu script; considera remover ou substituir com verificaÃ§Ã£o simples
    // if (!responded(doc)) return;
    const nextBtn = Array.from(
      doc.querySelectorAll("button.nui-button.nui-button-medium.nui-button-curved.nui-button-solid.nui-button-primary, button")
    ).find(b => {
      try {
        const txt = (b.innerText || '').toLowerCase();
        if (!txt) return false;
        if (txt.includes("avaliar") || txt.includes("experiÃªncia")) return false;
        return /avanÃ§ar|prÃ³xima|prÃ³ximo|continuar|next|prosseguir|seguinte|concluir|finalizar|enviar|avancar/i.test(txt);
      } catch (e) { return false; }
    });

    if (nextBtn && !nextBtn.disabled) {
      console.log("â–¶ï¸ Clicando no botÃ£o AvanÃ§ar (filtrado)");
      try { nextBtn.click(); } catch (e) {
        // fallback: despacha eventos simulados
        ["mousedown","mouseup","click"].forEach(evt => nextBtn.dispatchEvent(new MouseEvent(evt, { bubbles: true, cancelable: true })));
      }
    }
  }

  function clickInitialAdvance(doc = document) {
    const btn = Array.from(
      doc.querySelectorAll("button.nui-button.nui-button-medium.nui-button-curved.nui-button-solid.nui-button-primary, button")
    ).find(b => {
      try {
        const txt = (b.innerText || '').toLowerCase();
        if (!txt) return false;
        if (txt.includes("avaliar") || txt.includes("experiÃªncia")) return false;
        return /avanÃ§ar|prÃ³xima|prÃ³ximo|continuar|next|prosseguir|seguinte|concluir|finalizar|enviar|avancar/i.test(txt);
      } catch (e) { return false; }
    });

    if (btn && !btn.disabled) {
      console.log("â–¶ï¸ Clicando no botÃ£o inicial AvanÃ§ar (filtrado)");
      try { btn.click(); } catch (e) {}
      return true;
    }
    return false;
  }

  // ğŸ” Atualiza a interface e marca respostas
  function refresh(doc = document) {
    if (clickInitialAdvance(doc)) return;
    const rows = extractRows(doc);
    const box = createBox(doc);

    if (!rows.length) {
      box.innerHTML = "<b>âœ… H5P:</b><br><i>Nenhuma questÃ£o encontrada.</i>";
      return;
    }

    autoAnswer(rows, doc);
    setTimeout(() => autoClickNext(doc), 700);

    rows.sort((a, b) => a.letter.localeCompare(b.letter));
    let html = "<b>âœ… H5P Detectado:</b><br><table style='width:100%; font-size:12px;'>";
    rows.forEach((r) => {
      const dispText = r.text || (r.img ? `[imagem]` : '');
      html += `<tr><td>${r.correct ? "âœ…" : "âŒ"}</td><td>${r.letter})</td><td>${dispText}</td><td style="opacity:0.6;">(${r.type})</td></tr>`;
    });
    html += "</table>";
    box.innerHTML = html;
  }

  function scanIframe() {
    document.querySelectorAll("iframe").forEach((frame) => {
      try {
        const doc = frame.contentDocument;
        if (!doc) return;
        refresh(doc);
        doc.addEventListener("DOMContentLoaded", () => refresh(doc));
        console.log("ğŸ”„ Injetado em iframe (same-origin)");
      } catch (e) {
        console.warn("âš ï¸ Iframe bloqueado por CORS:", e);
      }
    });
  }

  // ğŸš€ InicializaÃ§Ã£o
  function init() {
    console.log("ğŸ§  Script H5P ativo em:", location.href);
    refresh(document);
    setInterval(() => refresh(document), 1000);
    setInterval(scanIframe, 1500);
  }

  init();
})();
